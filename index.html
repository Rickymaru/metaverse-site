<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#000000" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Rickymaru ‚Äì A New Kind of Nation</title>
  <meta name="description" content="Rickymaru is the first browser-based Web3 digital nation. Join the utopian digital society of explorers, creators, and dreamers." />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600&family=Inter:wght@400;600&display=swap" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
  <style>
    /* Custom font for title */
    @font-face {
      font-family: 'RExpanded';
      src: url('r expanded.png');
      font-display: block;
    }

    /* Base styles */
    :root {
      --accent-color: #fbb600;
      --accent-gradient: linear-gradient(45deg, #fbb600, #ffdd55);
      --transition-speed: 0.3s;
      --content-spacing: 2rem;
      --section-height: 100vh;
      --text-color: #fff;
      --bg-color: #000;
    }

    /* Reset */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    /* Hide scrollbar for Chrome, Safari and Opera */
    ::-webkit-scrollbar {
      width: 0;
      background: transparent;
    }

    /* Hide scrollbar for IE, Edge and Firefox */
    html {
      -ms-overflow-style: none;  /* IE and Edge */
      scrollbar-width: none;  /* Firefox */
      height: 100%;
    }

    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      color: #fff;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      line-height: 1.6;
      /* Force smooth scroll */
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* Particle canvas */
    #particle-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
    }

    /* Container to center everything and limit width */
    .container {
      height: 100vh;
      overflow-y: auto;
      position: relative;
      z-index: 2;
      scroll-behavior: smooth;
    }

    /* Hero section with full viewport height */
    .hero {
      min-height: 100vh;
      width: 100%;
      scroll-snap-align: start;
      scroll-snap-stop: normal;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 2rem;
      position: relative;
      z-index: 2;
      gap: 1rem;
      background: linear-gradient(to bottom, rgba(0,0,0,0.8), rgba(0,0,0,0.4));
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.5s ease, transform 0.5s ease;
    }
    
    /* Keep hero content in place */
    .hero h1,
    .hero p {
      position: relative;
      z-index: 1;
    }
    .hero h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: clamp(2.5rem, 8vw, 4.5rem);
      font-weight: 600;
      margin-bottom: 1rem;
      color: #fbb600;
      text-shadow: 0 0 15px rgba(251, 182, 0, 0.4);
      white-space: nowrap;
      letter-spacing: -0.02em;
      line-height: 1.1;
      animation: pulseGlow 8s cubic-bezier(0.4, 0, 0.2, 1) infinite;
    }
    .hero p {
      font-size: clamp(1rem, 4vw, 1.2rem);
      padding: 0 1rem;
      max-width: 700px;
      margin-top: 2rem;
      animation: fadeIn 1s ease-in forwards;
      opacity: 0;
      transform: translateY(15px);
      animation-fill-mode: forwards;
      animation-delay: 0.2s;
      user-select: none;
    }
    /* Realistic Vortex Portal - Canvas Based */
    .portal-container {
      position: relative;
      width: 320px;
      height: 320px;
      margin: 2rem auto;
      cursor: pointer;
      touch-action: manipulation;
      animation: fadeIn 1s ease-in forwards, pulseZoom 4s ease-in-out infinite;
      opacity: 0;
      transform: translate3d(0, 15px, 0);
      animation-fill-mode: forwards;
      animation-delay: 0.3s, 1.3s;
      will-change: transform;
      perspective: 600px;
      transform-style: preserve-3d;
      transition: transform 0.08s ease-out;
      border-radius: 50%;
      overflow: hidden;
    }
    
    /* Solid black background behind vortex - in front of background particles */
    .portal-background {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: rgba(0, 0, 0, 1);
      z-index: 0;
      pointer-events: none;
    }
    .portal-container:hover {
      animation-play-state: paused;
    }
    .portal-container canvas {
      display: block;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      position: relative;
      z-index: 2;
      /* Blur effect on inner edges - smoother transition for unified feel */
      mask-image: radial-gradient(circle, 
        black 0%, 
        black calc(100% - 70px), 
        rgba(0, 0, 0, 0.95) calc(100% - 60px),
        rgba(0, 0, 0, 0.85) calc(100% - 50px),
        rgba(0, 0, 0, 0.7) calc(100% - 40px),
        rgba(0, 0, 0, 0.5) calc(100% - 30px),
        rgba(0, 0, 0, 0.3) calc(100% - 20px),
        transparent calc(100% - 10px));
      -webkit-mask-image: radial-gradient(circle, 
        black 0%, 
        black calc(100% - 70px), 
        rgba(0, 0, 0, 0.95) calc(100% - 60px),
        rgba(0, 0, 0, 0.85) calc(100% - 50px),
        rgba(0, 0, 0, 0.7) calc(100% - 40px),
        rgba(0, 0, 0, 0.5) calc(100% - 30px),
        rgba(0, 0, 0, 0.3) calc(100% - 20px),
        transparent calc(100% - 10px));
    }
    
    /* Spinning signature color motion blurry O ring - on portal edges */
    .portal-outer-blur {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 10px solid transparent;
      border-top: 10px solid rgba(20, 30, 60, 0.45);
      border-right: 10px solid rgba(15, 25, 50, 0.3375);
      border-bottom: 10px solid rgba(20, 30, 60, 0.45);
      border-left: 10px solid rgba(15, 25, 50, 0.3375);
      pointer-events: none;
      z-index: 3;
      filter: blur(30px);
      opacity: 0.45;
      animation: spinRing 12s linear infinite;
      box-shadow: 0 0 25px rgba(20, 30, 60, 0.3), inset 0 0 25px rgba(15, 25, 50, 0.15), 0 0 0 1px rgba(100, 30, 30, 0.4);
      outline: 0.5px solid rgba(120, 40, 40, 0.5);
      outline-offset: -0.5px;
    }
    
    /* Spinning ring animation */
    @keyframes spinRing {
      0% {
        transform: translate(-50%, -50%) rotate(0deg);
      }
      100% {
        transform: translate(-50%, -50%) rotate(360deg);
      }
    }
    
    /* Motion effect for pull-in feeling */
    @keyframes blurPulse {
      0%, 100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }
      50% {
        transform: translate(-50%, -50%) scale(1.02);
        opacity: 0.9;
      }
    }
    
    /* Subtle rotation effect for motion */
    @keyframes blurRotate {
      0% {
        transform: translate(-50%, -50%) rotate(0deg);
      }
      100% {
        transform: translate(-50%, -50%) rotate(360deg);
      }
    }
    
    /* Blur effect only on inner edges for pull-in effect */
    .portal-container::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: radial-gradient(circle, 
        transparent 0%, 
        transparent calc(100% - 8px), 
        rgba(0, 0, 0, 0.4) calc(100% - 6px), 
        rgba(0, 0, 0, 0.7) calc(100% - 4px), 
        rgba(0, 0, 0, 0.9) calc(100% - 2px),
        rgba(0, 0, 0, 1) 100%);
      pointer-events: none;
      z-index: 1;
      filter: blur(528px);
      opacity: 1;
      animation: blurPulse 3s ease-in-out infinite, blurRotate 20s linear infinite;
    }
    
    /* Additional inner edge blur layer */
    .portal-container::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: radial-gradient(circle, 
        transparent 0%, 
        transparent calc(100% - 6px), 
        rgba(0, 0, 0, 0.5) calc(100% - 4px), 
        rgba(0, 0, 0, 0.8) calc(100% - 2px),
        rgba(0, 0, 0, 1) 100%);
      pointer-events: none;
      z-index: 2;
      filter: blur(360px);
      opacity: 0.8;
      animation: blurPulse 3s ease-in-out infinite 0.5s, blurRotate 25s linear infinite reverse;
    }
    .portal-text {
      position: absolute;
      width: 100%;
      bottom: -45px;
      text-align: center;
      font-family: 'Orbitron', sans-serif;
      font-weight: 600;
      color: #fbb600;
      text-shadow: 0 0 15px rgba(251, 182, 0, 0.8), 0 0 30px rgba(251, 182, 0, 0.6);
      font-size: clamp(1rem, 2.5vw, 1.2rem);
      transition: all 0.3s ease;
    }
    .portal-container:hover .portal-text {
      color: #ffdd55;
      text-shadow: 0 0 20px rgba(251, 182, 0, 0.9), 0 0 40px rgba(251, 182, 0, 0.7);
    }
    
    /* Step in text - just text, no button styling */
    .step-in-button {
      display: block;
      margin: -20px auto 0;
      padding: 0;
      background: transparent;
      border: none;
      color: #fbb600;
      font-family: 'Orbitron', sans-serif;
      font-weight: 600;
      font-size: clamp(0.9rem, 2vw, 1.1rem);
      text-transform: lowercase;
      letter-spacing: 0.1em;
      cursor: pointer;
      transition: all 0.3s ease;
      text-shadow: 0 0 10px rgba(251, 182, 0, 0.6);
      position: relative;
      z-index: 10;
    }
    
    .step-in-button:hover {
      color: #ffdd55;
      text-shadow: 0 0 15px rgba(251, 182, 0, 0.8), 0 0 25px rgba(251, 182, 0, 0.6);
    }
    
    /* Black ring overlay closing from edges to vortex center */
    .black-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.1s ease;
    }
    
    .black-overlay.active {
      opacity: 1;
      pointer-events: auto;
    }
    
    body.fading-out {
      overflow: hidden;
    }
    
    
    
    /* Bottom Portal Section */
    .portal-section-bottom {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 1rem 2rem 2rem;
      margin-top: 0;
    }
    
    /* Bottom portal - half the size */
    #portal-container-bottom {
      width: 160px !important;
      height: 160px !important;
    }
    
    /* Mobile responsive */
    @media (max-width: 768px) {
      .portal-container {
        width: 280px;
        height: 280px;
        margin: 1.5rem auto;
      }
      .portal-text {
        font-size: clamp(0.9rem, 2vw, 1rem);
        bottom: -40px;
      }
      
      /* Remove mask-image gradient on mobile - it makes it too grey/visible */
      .portal-container canvas {
        mask-image: none;
        -webkit-mask-image: none;
      }
      
      /* Increase blur and reduce opacity on mobile to remove grey edges */
      .portal-outer-blur {
        filter: blur(50px);
        opacity: 0.25;
      }
      
      /* Bottom portal - same settings */
      #portal-container-bottom {
        width: 140px !important;
        height: 140px !important;
      }
      
      /* Remove mask-image gradient on mobile for bottom portal too */
      #portal-container-bottom canvas {
        mask-image: none;
        -webkit-mask-image: none;
      }
      
      /* Increase blur and reduce opacity on mobile for bottom portal */
      #portal-container-bottom .portal-outer-blur {
        filter: blur(50px);
        opacity: 0.25;
      }
    }

    @keyframes pulseGlow {
      0%, 100% {
        text-shadow: 0 0 15px rgba(251, 182, 0, 0.4);
      }
      20% {
        text-shadow: 0 0 15px rgba(251, 182, 0, 0.4);
      }
      30% {
        text-shadow: 0 0 20px rgba(251, 182, 0, 0.5);
      }
      50% {
        text-shadow: 0 0 25px rgba(251, 182, 0, 0.6),
                     0 0 35px rgba(251, 182, 0, 0.3);
      }
      70% {
        text-shadow: 0 0 20px rgba(251, 182, 0, 0.5);
      }
      80% {
        text-shadow: 0 0 15px rgba(251, 182, 0, 0.4);
      }
    }

    @keyframes fadeIn {
      to { opacity: 1; transform: translate3d(0, 0, 0); }
    }
    
    @keyframes pulseZoom {
      0%, 100% { transform: translate3d(0, 0, 0) scale(1); }
      50% { transform: translate3d(0, 0, 0) scale(1.03); }
    }
    
    @keyframes pullIn {
      0% { 
        transform: translate3d(0, 0, 0) scale(1);
        filter: blur(0px);
      }
      100% { 
        transform: translate3d(0, 0, 0) scale(3.5);
        filter: blur(8px);
      }
    }

    /* Section styling with subtle fade-in on scroll */
    section, header.hero {
      min-height: 100vh;
      width: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      position: relative;
      padding: 2rem;
      text-align: center;
      opacity: 0;
      transform: translateY(30px);
      transition: opacity 0.6s ease-out, transform 0.6s ease-out;
      z-index: 2;
    }
    section::before, header.hero::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      z-index: -1;
      backdrop-filter: blur(5px);
    }
    section.intersecting, header.hero.intersecting {
      opacity: 1;
      transform: translateY(0);
      z-index: 3;
    }

    /* Vignette effect */
    section::before, header.hero::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(circle at center, transparent 0%, rgba(0,0,0,0.8) 100%);
      opacity: 0;
      transition: opacity 0.8s ease;
      pointer-events: none;
      z-index: 1;
    }
    section.visible::before, header.hero.visible::before {
      opacity: 1;
    }

    /* Content wrapper for better fade control */
    .content-wrapper {
      position: relative;
      z-index: 4;
      max-width: 1200px;
      width: 100%;
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.6s ease-out 0.2s, transform 0.6s ease-out 0.2s;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 2rem;
    }
    section.intersecting .content-wrapper,
    header.hero.intersecting .content-wrapper {
      opacity: 1;
      transform: translateY(0);
    }

    /* Staggered animations for features and roadmap items */
    .features li, .roadmap li {
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.5s ease-out, transform 0.5s ease-out;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(5px);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1rem;
      border: 1px solid rgba(251, 182, 0, 0.1);
    }
    section.intersecting .features li,
    section.intersecting .roadmap li,
    header.hero.intersecting .features li,
    header.hero.intersecting .roadmap li {
      opacity: 1;
      transform: translateY(0);
    }
    .features li:nth-child(1), .roadmap li:nth-child(1) { transition-delay: 0.1s; }
    .features li:nth-child(2), .roadmap li:nth-child(2) { transition-delay: 0.2s; }
    .features li:nth-child(3), .roadmap li:nth-child(3) { transition-delay: 0.3s; }
    .features li:nth-child(4), .roadmap li:nth-child(4) { transition-delay: 0.4s; }
    .features li:nth-child(5), .roadmap li:nth-child(5) { transition-delay: 0.5s; }

    .section-title {
      font-family: 'Orbitron', sans-serif;
      font-weight: 600;
      font-size: clamp(2rem, 4vw, 2.8rem);
      color: #fbb600;
      margin-bottom: 30px;
      user-select: none;
    }

    section p {
      font-size: clamp(1.1rem, 4vw, 1.3rem);
      max-width: 800px;
      margin: 0 auto 1.5rem;
      line-height: 1.7;
    }

    ul.features {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      list-style: none;
      gap: 1.25rem;
      padding: 0.75rem 0;
      margin: 30px auto 0 auto;
      max-width: 700px;
      width: 100%;
    }
    ul.features li {
      width: 100%;
      max-width: 700px;
      background: rgba(255,255,255,0.05);
      padding: 1.5rem;
      border-radius: 15px;
      backdrop-filter: blur(6px);
      font-weight: 600;
      font-size: clamp(1.1rem, 4vw, 1.2rem);
      box-shadow: 0 0 10px #fbb60033;
      user-select: none;
      cursor: default;
      touch-action: manipulation;
      border: 1px solid rgba(251,182,0,0.08);
      transition: box-shadow 0.3s;
      margin: 0 auto;
    }
    .r-logo-absolute {
      position: absolute;
      left: 2rem;
      top: calc(50% + 1.5rem);
      width: 64px;
      height: 64px;
      background: url('r expanded.png') no-repeat center center / contain;
      z-index: 10;
      pointer-events: none;
    }
    @media (max-width: 900px) {
      ul.features li {
        max-width: 95vw;
      }
      ul.features {
        max-width: 95vw;
      }
      .r-logo-absolute {
        left: 1rem;
        width: 48px;
        height: 48px;
      }
    }
    @media (max-width: 600px) {
      ul.features li {
        padding: 1rem;
        font-size: 1rem;
      }
    }

    /* Roadmap style */
    .roadmap {
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
      max-width: 700px;
      margin: 0 auto;
      padding: 0 0.5rem;
      margin-top: 30px;
    }
    .roadmap span {
      display: block;
      background: #111;
      padding: 1.25rem;
      border-left: 6px solid #fbb600;
      font-weight: 600;
      font-size: clamp(1rem, 4vw, 1.15rem);
      border-radius: 5px;
      user-select: none;
      box-shadow: 0 0 10px #fbb60044;
      touch-action: manipulation;
    }

    /* Call to action section */
    .cta {
      margin-top: 50px;
      text-align: center;
      user-select: none;
      padding: 0 1rem;
    }
    .cta form {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      max-width: 400px;
      margin: 0 auto;
    }
    .cta input[type=email] {
      width: 100%;
      padding: 1rem;
      font-size: 16px; /* Prevent iOS zoom */
      border-radius: 10px;
      margin: 0;
      border: none;
      border-radius: 10px;
      outline-offset: 3px;
      outline-color: #fbb600;
      transition: outline-color 0.3s ease;
    }
    .cta input[type=email]:focus {
      outline-color: #ffdd55;
    }
    .cta button {
      background-color: #fbb600;
      border: none;
      padding: 1rem;
      font-weight: 700;
      font-size: 1rem;
      border-radius: 10px;
      cursor: pointer;
      transition: background-color 0.3s ease;
      user-select: none;
      touch-action: manipulation;
    }
    .cta button:hover {
      background-color: #ffdd55;
    }

    /* Social icons */
    .social-icons {
      margin-top: 25px;
      display: flex;
      justify-content: center;
      gap: 1.5rem;
      padding: 1rem;
    }
    .social-icons a {
      color: #fff;
      font-size: 24px;
      transition: all 0.3s ease;
      opacity: 0.8;
      text-decoration: none;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(5px);
    }
    .social-icons a:hover {
      opacity: 1;
      transform: translateY(-3px);
      background: rgba(251, 182, 0, 0.2);
      color: #fbb600;
    }
    .social-icons a.discord:hover { color: #5865F2; }
    .social-icons a.instagram:hover { color: #E1306C; }
    .social-icons a.medium:hover { color: #00ab6c; }
    .social-icons a.github:hover { color: #333; }

    /* FAQ Section */
    .faq-section {
      padding: 30px 1rem;
      max-width: 600px;
      margin: 0 auto;
    }
    .faq-item {
      margin-bottom: 0.75rem;
      border: 1px solid rgba(251, 182, 0, 0.2);
      border-radius: 8px;
      overflow: hidden;
      transition: border-color 0.3s ease;
    }
    .faq-item:hover {
      border-color: rgba(251, 182, 0, 0.4);
    }
    .faq-question {
      padding: 0.75rem 1rem;
      background: rgba(255, 255, 255, 0.05);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      font-weight: 600;
      font-size: clamp(0.9rem, 3.5vw, 1rem);
      transition: background-color 0.3s ease;
      user-select: none;
      gap: 1rem;
      line-height: 1.4;
      text-align: left;
    }
    .faq-question > span {
      flex: 1;
      text-align: left;
    }
    .faq-question:hover {
      background: rgba(255, 255, 255, 0.1);
    }
    .faq-question::after {
      content: '+';
      font-size: 1.25rem;
      transition: transform 0.3s ease;
      flex-shrink: 0;
      width: 1.5rem;
      text-align: center;
    }
    .faq-item.active .faq-question::after {
      transform: rotate(45deg);
    }
    .faq-answer {
      padding: 0;
      max-height: 0;
      overflow: hidden;
      transition: all 0.3s ease;
      background: rgba(0, 0, 0, 0.3);
      font-size: clamp(0.8rem, 3.5vw, 0.9rem);
      line-height: 1.4;
    }
    .faq-item.active .faq-answer {
      padding: 0.75rem;
      max-height: 400px;
    }
    .faq-answer p {
      margin: 0;
      opacity: 0.9;
    }

    /* Footer */
    footer {
      text-align: center;
      padding: 40px 20px;
      font-size: 0.9rem;
      color: #888;
      user-select: none;
    }

    /* Mobile-specific styles */
    @media (max-width: 768px) {
      .section-title {
        font-size: clamp(1.5rem, 6vw, 2rem);
        margin-bottom: 1rem;
      }
      section p {
        font-size: clamp(0.9rem, 4vw, 1.1rem);
        padding: 0 0.5rem;
      }
      footer {
        padding: 2rem 1rem;
        font-size: 0.8rem;
      }

      .faq-section {
        padding: 20px 1rem;
      }
      .faq-question {
        padding: 0.6rem;
      }
      .faq-item.active .faq-answer {
        padding: 0.6rem;
      }
      .hero h1 {
        font-size: clamp(1.2rem, 6vw, 2rem);
        padding: 0 0.5rem;
        transform-origin: left center;
        transform: scale(0.9);
      }
    }

    /* Custom cursor */
    @media (hover: hover) {
      * {
        cursor: none !important;
      }
      .custom-cursor {
        position: fixed;
        width: 20px;
        height: 20px;
        pointer-events: none;
        z-index: 9999;
        mix-blend-mode: difference;
        will-change: transform;
        transform: translate3d(0, 0, 0);
        backface-visibility: hidden;
      }
      .custom-cursor::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 8px;
        height: 8px;
        background: #fbb600;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        box-shadow: 0 0 10px #fbb600, 0 0 20px #fbb600;
        animation: pulse 2s infinite;
      }
      .custom-cursor::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 20px;
        height: 20px;
        border: 2px solid #fbb600;
        border-radius: 50%;
        transform: translate(-50%, -50%) scale(0.8);
        opacity: 0.5;
        transition: transform 0.2s ease, opacity 0.2s ease;
      }
      .custom-cursor.hover {
        transform: scale(1.5);
      }
      .custom-cursor.hover::after {
        transform: translate(-50%, -50%) scale(1.2);
        opacity: 0.3;
        border-color: #ffdd55;
      }
      .custom-cursor.click {
        transform: scale(0.8);
      }
      .custom-cursor.click::after {
        transform: translate(-50%, -50%) scale(1.5);
        opacity: 0.2;
      }
      .cursor-wave {
        position: fixed;
        pointer-events: none;
        z-index: 9998;
        border: 2px solid #fbb600;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        opacity: 0;
        animation: wave 0.8s ease-out;
      }
      @keyframes pulse {
        0% { transform: translate(-50%, -50%) scale(1); }
        50% { transform: translate(-50%, -50%) scale(1.1); }
        100% { transform: translate(-50%, -50%) scale(1); }
      }
      @keyframes wave {
        0% { width: 20px; height: 20px; opacity: 0.8; }
        100% { width: 100px; height: 100px; opacity: 0; }
      }
    }

    /* Touch device styles */
    @media (hover: none) {
      * {
        cursor: auto !important;
      }
      .custom-cursor, .cursor-wave {
        display: none;
      }
    }

    /* R menu button - no glow, just the PNG */
    .arc-menu-trigger {
      position: fixed;
      left: 2rem;
      top: 50%;
      transform: translateY(-50%) scale(0.8);
      width: 64px;
      height: 64px;
      background: url('r expanded.png') no-repeat center center / contain;
      border: none;
      border-radius: 50%;
      background-color: transparent;
      cursor: pointer;
      z-index: 1001;
      opacity: 0;
      transition: opacity 0.7s cubic-bezier(.4,0,.2,1), transform 0.7s cubic-bezier(.4,0,.2,1);
      box-shadow: none;
    }
    .arc-menu-trigger.visible {
      opacity: 1;
      transform: translateY(-50%) scale(1);
    }
    /* Arc menu container */
    .arc-menu {
      position: fixed;
      left: 2rem;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
      z-index: 1000;
    }
    .arc-menu.open {
      pointer-events: auto;
    }
    /* Arc menu items */
    .arc-menu-item {
      position: absolute;
      left: 32px;
      top: 32px;
      transform: scale(0);
      opacity: 0;
      background: none;
      color: #fff;
      padding: 0;
      border-radius: 0;
      font-size: 1.4rem;
      font-weight: 700;
      white-space: nowrap;
      box-shadow: none;
      border: none;
      transition: transform 0.5s cubic-bezier(.4,0,.2,1), opacity 0.5s cubic-bezier(.4,0,.2,1);
      cursor: pointer;
      user-select: none;
      pointer-events: auto;
      text-shadow: 0 2px 12px #fbb600, 0 0 8px #fff2;
      letter-spacing: 0.08em;
      text-align: left;
      transform-origin: left center;
      background: none;
      -webkit-background-clip: initial;
      -webkit-text-fill-color: initial;
      background-clip: initial;
      text-fill-color: initial;
      animation: none;
    }
    .arc-menu.open .arc-menu-item {
      opacity: 1;
      /* transform will be set dynamically */
    }
    /* Arc positions for 6 items, fanning out to the right in a semi-circle */
    /* 0deg is directly right, 60deg is up-right, -60deg is down-right */
    .arc-menu.open .arc-menu-item:nth-child(1) { transition-delay: 0.05s; }
    .arc-menu.open .arc-menu-item:nth-child(2) { transition-delay: 0.10s; }
    .arc-menu.open .arc-menu-item:nth-child(3) { transition-delay: 0.15s; }
    .arc-menu.open .arc-menu-item:nth-child(4) { transition-delay: 0.20s; }
    .arc-menu.open .arc-menu-item:nth-child(5) { transition-delay: 0.25s; }
    .arc-menu.open .arc-menu-item:nth-child(6) { transition-delay: 0.30s; }
    @keyframes shineText {
      0% {
        background-position: -100% 0;
      }
      100% {
        background-position: 200% 0;
      }
    }

    @media (max-width: 1024px) {
      .arc-menu-trigger {
        top: 2rem;
        left: 0.5rem;
        transform: none;
        width: 56px;
        height: 56px;
      }
      .arc-menu {
        left: 0.5rem;
        top: 2rem;
        transform: none;
      }
    }
  </style>
</head>
<body>
  <!-- Add custom cursor element -->
  <div class="custom-cursor"></div>

  <!-- Black overlay for transition -->
  <div class="black-overlay" id="black-overlay"></div>

  <canvas id="particle-canvas"></canvas>

  <button class="arc-menu-trigger" aria-label="Open menu"></button>
  <nav class="arc-menu">
    <div class="arc-menu-item">About</div>
    <div class="arc-menu-item">Contact</div>
    <div class="arc-menu-item">Privacy</div>
    <div class="arc-menu-item">Cookies</div>
    <div class="arc-menu-item">Terms</div>
  </nav>

  <div class="container">
    <header class="hero" id="hero">
      <h1>rickymaru.metaverse</h1>
      <div class="portal-container" id="portal-container">
        <div class="portal-background"></div>
        <canvas id="vortex-portal"></canvas>
        <div class="portal-outer-blur"></div>
      </div>
      <button class="step-in-button">step in</button>
      <p>A borderless society for explorers, creators, and dreamers ‚Äì built on trust, imagination and digital freedom.</p>
    </header>

    <section>
      <h2 class="section-title">The Vision</h2>
      <p>Rickymaru is the first browser-based web3 digital nation.</p>
    </section>

    <section>
      <h2 class="section-title">Digital Society</h2>
      <p>It merges identity, social connection, commerce and exploration in one unified realm.</p>
    </section>

    <section>
      <h2 class="section-title">A Belonging-First Future</h2>
      <p>Rickymaru is more than a platform ‚Äî it's a foundation for a new kind of world where everyone belongs.</p>
    </section>

    <section>
      <h2 class="section-title">What You Can Do</h2>
      <p>We believe in a digital future where identity is yours, creativity is currency and your community is global.</p>
      <ul class="features">
        <li>üõí Shop immersive NFT experiences</li>
        <li>üé≠ Customise your avatar and identity</li>
        <li>üéâ Join events, exhibitions & social hubs</li>
        <li>üó≥Ô∏è Engage in community governance</li>
      </ul>
    </section>

    <section>
      <h2 class="section-title">Roadmap</h2>
      <div class="roadmap">
        <span>üå± Genesis ‚Äì Concept launched, community forming (Q4 2025)</span>
        <span>üß™ Prototype &amp; MVP ‚Äì Experience preview &amp; first citizen trials (Q3 2026)</span>
        <span>üåç Phase 1 Nationhood ‚Äì Full realm with shopping, avatars, social layer (Late 2026)</span>
        <span>Ô∏è Phase 2 Expansion ‚Äì DAO governance, economic layer, wider onboarding (Mid-Late 2027)</span>
        <span>üöÄ Phase 3 Open Universe ‚Äì Integration with wider metaverses and institutions (2028+)</span>
      </div>
    </section>

    <section class="cta">
      <h2 class="section-title">Join the Movement</h2>
      <p>Become a founding citizen. Shape the new world!</p>
      <form onsubmit="return false;">
        <input type="email" placeholder="Enter your email" inputmode="email" autocomplete="email" />
        <button type="submit">Sign Up</button>
      </form>
      <div class="social-icons">
        <a href="https://discord.gg/metaversetoken" target="_blank" rel="noopener noreferrer" class="discord" aria-label="Discord">
          <i class="fab fa-discord"></i>
        </a>
        <a href="https://instagram.com/orangekiddo" target="_blank" rel="noopener noreferrer" class="instagram" aria-label="Instagram">
          <i class="fab fa-instagram"></i>
        </a>
        <a href="https://medium.com/@metaversetoken" target="_blank" rel="noopener noreferrer" class="medium" aria-label="Medium">
          <i class="fab fa-medium"></i>
        </a>
        <a href="https://github.com/Rickymaru/metaverse-site" target="_blank" rel="noopener noreferrer" class="github" aria-label="GitHub">
          <i class="fab fa-github"></i>
        </a>
      </div>
      
      <!-- Second Portal at Bottom -->
      <div class="portal-section-bottom">
        <div class="portal-container" id="portal-container-bottom">
          <div class="portal-background"></div>
          <canvas id="vortex-portal-bottom"></canvas>
          <div class="portal-outer-blur"></div>
        </div>
      </div>
    </section>

    <section class="faq-section">
      <h2 class="section-title">Frequently Asked Questions</h2>
      <div class="faq-container">
        <div class="faq-item">
          <div class="faq-question"><span>What is Rickymaru?</span></div>
          <div class="faq-answer">
            <p>A browser-based digital nation built on Web3. It's a place to explore, connect, shop, and shape your identity in immersive virtual realms.</p>
          </div>
        </div>
        <div class="faq-item">
          <div class="faq-question"><span>Who is it for?</span></div>
          <div class="faq-answer">
            <p>Anyone curious about the future of digital living ‚Äî creators, explorers, educators, investors, and everyday citizens of the internet.</p>
          </div>
        </div>
        <div class="faq-item">
          <div class="faq-question"><span>Is Rickymaru a metaverse?</span></div>
          <div class="faq-answer">
            <p>Not exactly. It's more than that. Rickymaru blends identity, economy, and creativity to build a sovereign digital society ‚Äî not just a 3D world.</p>
          </div>
        </div>
        <div class="faq-item">
          <div class="faq-question"><span>How do I access it?</span></div>
          <div class="faq-answer">
            <p>Through your browser ‚Äî no downloads, no VR headset needed. You'll be able to explore using your phone or computer. VR will come later.</p>
          </div>
        </div>
        <div class="faq-item">
          <div class="faq-question"><span>What can I do inside Rickymaru?</span></div>
          <div class="faq-answer">
            <p>Create your avatar, shop digital goods, attend events, explore immersive realms, and eventually participate in shaping governance and culture.</p>
          </div>
        </div>
        <div class="faq-item">
          <div class="faq-question"><span>Is there a token or economy?</span></div>
          <div class="faq-answer">
            <p>Yes ‚Äî the RRR token (Name TBD) will power transactions, access, and eventually voting. Initial airdrop is limited to early contributors.</p>
          </div>
        </div>
        <div class="faq-item">
          <div class="faq-question"><span>How is this different from other Web3 or metaverse projects?</span></div>
          <div class="faq-answer">
            <p>Rickymaru is not about hype ‚Äî it's a structured vision for a digital society. It prioritizes accessibility, real use cases, and community-driven growth.</p>
          </div>
        </div>
        <div class="faq-item">
          <div class="faq-question"><span>Is this a game?</span></div>
          <div class="faq-answer">
            <p>No. There are no quests or enemies. Rickymaru is a living digital environment, not a video game. Think digital city, not digital battlefield.</p>
          </div>
        </div>
        <div class="faq-item">
          <div class="faq-question"><span>Is this being used for education or research?</span></div>
          <div class="faq-answer">
            <p>Yes ‚Äî Rickymaru is also being explored as a platform for virtual education, digital residency, and academic collaboration. Research is ongoing through MSc and future PhD studies.</p>
          </div>
        </div>
        <div class="faq-item">
          <div class="faq-question"><span>Can brands or educators get involved?</span></div>
          <div class="faq-answer">
            <p>Absolutely. We're exploring partnerships with educators, creators, and ethical brands who want to help shape a better digital future.</p>
          </div>
        </div>
      </div>
    </section>

    <footer>
      &copy; 2025 Rickymaru ‚Äì All rights reserved.
    </footer>
  </div>

  <script>
    // Background particle system
    const canvas = document.getElementById('particle-canvas');
    const ctx = canvas.getContext('2d');

    // Set canvas size
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Background Particle class
    class BackgroundParticle {
      constructor() {
        this.reset();
        this.glowPhase = Math.random() * Math.PI * 2;
        this.glowSpeed = 0.2 + Math.random() * 0.1; // very slow
      }

      reset() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.size = Math.random() * 2 + 0.5;
        this.speedX = (Math.random() - 0.5) * 0.3;
        this.speedY = (Math.random() - 0.5) * 0.3;
        this.opacity = Math.random() * 0.5 + 0.2;
      }

      update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.glowPhase += this.glowSpeed * 0.01; // very slow
        if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
          this.reset();
        }
      }

      draw() {
        // Subtle glow effect
        const glow = 0.15 + 0.10 * Math.sin(this.glowPhase);
        ctx.save();
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.shadowColor = `rgba(251, 182, 0, ${glow})`;
        ctx.shadowBlur = 12;
        ctx.fillStyle = `rgba(251, 182, 0, ${this.opacity})`;
        ctx.fill();
        ctx.restore();
      }
    }

    // Create background particles
    const backgroundParticles = [];
    const particleCount = Math.min(120, Math.floor(window.innerWidth * window.innerHeight / 18000));
    
    for (let i = 0; i < particleCount; i++) {
      backgroundParticles.push(new BackgroundParticle());
    }

    // Background animation loop
    function animateBackground() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      backgroundParticles.forEach(particle => {
        particle.update();
        particle.draw();
      });

      // Draw connections between nearby particles
      backgroundParticles.forEach((particle, i) => {
        backgroundParticles.slice(i + 1).forEach(otherParticle => {
          const dx = particle.x - otherParticle.x;
          const dy = particle.y - otherParticle.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < 110) {
            ctx.beginPath();
            ctx.strokeStyle = `rgba(251, 182, 0, ${0.12 * (1 - distance / 110)})`;
            ctx.lineWidth = 0.6;
            ctx.moveTo(particle.x, particle.y);
            ctx.lineTo(otherParticle.x, otherParticle.y);
            ctx.stroke();
          }
        });
      });

      requestAnimationFrame(animateBackground);
    }

    // Start background animation
    animateBackground();

    // Initialize Intersection Observer
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('intersecting');
        } else {
          entry.target.classList.remove('intersecting');
        }
      });
    }, {
      threshold: 0.5
    });

    // Observe all sections
    document.querySelectorAll('section, header.hero').forEach(section => {
      observer.observe(section);
    });

    // Initialize first section
    document.addEventListener('DOMContentLoaded', () => {
      const firstSection = document.querySelector('header.hero');
      firstSection.classList.add('intersecting');

      // Initialize FAQ accordion
      document.querySelectorAll('.faq-question').forEach(question => {
        question.addEventListener('click', () => {
          const answer = question.nextElementSibling;
          const isOpen = question.classList.contains('open');
          
          // Close all other questions
          document.querySelectorAll('.faq-question').forEach(q => {
            if (q !== question) {
              q.classList.remove('open');
              q.nextElementSibling.style.maxHeight = null;
            }
          });

          // Toggle current question
          question.classList.toggle('open');
          if (!isOpen) {
            answer.style.maxHeight = answer.scrollHeight + 'px';
          } else {
            answer.style.maxHeight = null;
          }
        });
      });

      // Realistic Vortex Portal - Particle System
      (() => {
        const canvas = document.getElementById('vortex-portal');
        const portalContainer = document.getElementById('portal-container');
        
        if (!canvas || !portalContainer) return;
        
        const ctx = canvas.getContext('2d');
        let animationId = null;
        let startTime = null;
        let rotation = 0;
        
        // Resize canvas
        function resizeCanvas() {
          const rect = portalContainer.getBoundingClientRect();
          canvas.width = rect.width;
          canvas.height = rect.height;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Particle system - realistic vortex with 2 main arms
        const particles = [];
        const edgeParticles = []; // Particles in blurry edge section
        const numArms = 2; // Two main arms like reference
        let activeParticleCount = 0;
        let edgeParticleCount = 0;
        let globalCreationCounter = 0; // Track actual creation order
        let firstParticleDisappeared = false; // Track when first particle disappears
        let lastEdgeParticleTime = 0; // Track edge particle creation timing
        // Optimize particle count based on device performance
        const isMobile = window.innerWidth < 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const particlesPerFrame = isMobile ? 3 : 4; // Reduced generation rate for better performance
        const centerX = () => canvas.width / 2;
        const centerY = () => canvas.height / 2;
        
        // Ensure animation continues during expansion
        let isAnimating = true;
        
        // Base radius for particle field
        const initialBaseRadius = 240;
        
        // Calculate max particles needed for continuous loop - optimized for performance
        const calculatedMaxParticles = isMobile ? 600 : 900; // Further reduced to prevent lag
        
        // Get current baseRadius
        function getCurrentBaseRadius() {
          return initialBaseRadius;
        }
        
        // Particle class - realistic small glowing dots
        class Particle {
          constructor(armIndex, particleIndex, totalParticles, creationOrder, creationTime) {
            this.armIndex = armIndex;
            this.particleIndex = particleIndex;
            this.totalParticles = totalParticles;
            this.creationOrder = creationOrder; // Actual order of creation
            this.creationTime = creationTime || performance.now(); // Time when particle was created
            // Random fade-in: particles fade in at different rates when entering field
            this.fadeInDuration = 0.3 + Math.random() * 0.9; // More random: 0.3-1.2 seconds for varied appearance
            this.fadeInDelay = Math.random() * 0.3; // Random delay before fade-in starts (0-0.3s)
            this.reset(true);
          }
          
          reset(isInitial = false) {
            const armAngle = (this.armIndex / numArms) * Math.PI * 2;
            const baseRadius = getCurrentBaseRadius(); // Dynamic radius that expands
            
            // Spiral offset - creates clearly visible spiral arms
            // Use creation order to position particles along spiral with tighter spacing
            const baseSpiralOffset = this.creationOrder * 0.25; // Increased spacing for more distinct spiral arms
            const randomAngleVariation = (Math.random() - 0.5) * 0.05; // Minimal variation to maintain clear spiral
            const spiralOffset = baseSpiralOffset + randomAngleVariation;
            
            if (isInitial) {
              // For initial particles: start at outer edge with organic shape but maintain spiral
              const radiusVariation = (Math.random() - 0.5) * 35; // Organic edge variation
              const angleVariation = (Math.random() - 0.5) * 0.2; // Reduced angle variation to maintain spiral
              this.radius = baseRadius + radiusVariation; // Irregular outer edge
              this.angle = armAngle + spiralOffset + angleVariation;
            } else {
              // Regenerated particles: always start at outer edge with minimal variation to maintain spiral
              const radiusVariation = (Math.random() - 0.5) * 35; // Organic edge variation
              const angleVariation = (Math.random() - 0.5) * 0.15; // Reduced angle variation to maintain spiral
              this.radius = baseRadius + radiusVariation;
              this.angle = armAngle + this.initialSpiralOffset + (rotation % (Math.PI * 2)) + angleVariation;
            }
            
            this.baseRadius = baseRadius;
            this.initialSpiralOffset = spiralOffset; // Store for maintaining spiral shape
            
            
            // Signature color palette: #fbb600 (44¬∞ orange-gold) and neighboring warm tones
            // Use angle to create color gradient that follows the spiral pattern
            const normalizedAngle = ((this.angle % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2); // Normalize to 0-2œÄ
            const angleColorProgress = normalizedAngle / (Math.PI * 2); // 0 to 1 based on angle
            
            // Signature color #fbb600 is ~44¬∞ (orange-gold)
            // Neighboring colors: red-orange (25¬∞), orange (35¬∞), signature (44¬∞), yellow-orange (50¬∞), yellow (55¬∞)
            // Create smooth gradient through these warm tones
            const signatureHue = 44; // #fbb600 signature color
            const hueRange = 30; // Range of neighboring colors (¬±15¬∞ from signature)
            const baseHue = signatureHue + (angleColorProgress - 0.5) * hueRange; // Vary ¬±15¬∞ around signature
            this.hue = (baseHue + (Math.random() - 0.5) * 6) % 360; // Add slight random variation, wrap around
            this.opacity = 0.65 + Math.random() * 0.35; // Increased opacity by ~15% for better visibility (0.65-1.0)
            
            // Small varied sizes for realistic feel - more variation
            this.size = 0.6 + Math.random() * 3.0; // More size variation
            // Base rotation speed: will be adjusted based on distance from center
            // Particles near center rotate faster, outer ones slower (realistic spiral motion)
            this.baseSpeed = 0.007 + Math.random() * 0.003; // Base speed for clear visibility
            this.speed = this.baseSpeed; // Initial speed, will be adjusted in update()
            this.pullSpeed = 0.97 + Math.random() * 0.01; // Faster pull to match rotation speed
          }
          
          update(time) {
            // Realistic spiral motion: particles near center rotate faster, outer ones slower
            // Speed is inversely proportional to radius (like real spiral galaxies)
            // Moderate speed difference - visible but not too fast
            const normalizedRadius = Math.max(this.radius / this.baseRadius, 0.1); // Normalize, prevent division by zero
            const speedMultiplier = 0.5 + (1 / normalizedRadius) * 0.8; // Moderate: 1x at edge, ~8-9x at center
            const adjustedSpeed = this.baseSpeed * speedMultiplier;
            
            // Clockwise rotation (positive) - speed varies based on distance from center
            this.angle += adjustedSpeed;
            
            // Pull inward - each particle has its own pull speed (set in reset)
            this.radius *= this.pullSpeed;
            
            // Reset when very close to center (almost invisible)
            const resetThreshold = 1.5; // Very close to center - particles disappear when invisible
            
            // Force regeneration if particle is too close to center (invisible)
            if (this.radius < resetThreshold) {
              // Mark that first particle has disappeared (for initial build-up)
              if (this.creationOrder === 0 && !firstParticleDisappeared) {
                firstParticleDisappeared = true;
              }
              // Reset creation time for fade-in effect when regenerated
              this.creationTime = time;
              this.fadeInDuration = 0.3 + Math.random() * 0.9; // More random: 0.3-1.2 seconds for varied appearance
              this.fadeInDelay = Math.random() * 0.3; // Random delay before fade-in starts (0-0.3s)
              this.reset(false); // Regenerate at outer edge
            }
          }
          
          getPosition() {
            const x = centerX() + Math.cos(this.angle + rotation) * this.radius;
            const y = centerY() + Math.sin(this.angle + rotation) * this.radius;
            return { x, y };
          }
          
          draw(currentTime) {
            const pos = this.getPosition();
            const distanceFromCenter = Math.min(this.radius / this.baseRadius, 1);
            
            // Fade in effect - particles gradually appear when entering field (random timing)
            const timeSinceCreation = (currentTime - this.creationTime) / 1000; // Convert to seconds
            let fadeInAlpha = 1.0;
            
            // Account for random delay before fade-in starts
            const timeAfterDelay = Math.max(0, timeSinceCreation - (this.fadeInDelay || 0));
            
            if (timeAfterDelay < this.fadeInDuration) {
              // Gradually fade in from 0 to 1 over fadeInDuration with smooth easing
              const progress = Math.min(1, timeAfterDelay / this.fadeInDuration);
              // Smooth ease-in curve for more realistic, natural appearance
              fadeInAlpha = progress * progress * (3 - 2 * progress); // Smoothstep function for natural fade
            } else if (timeSinceCreation < (this.fadeInDelay || 0)) {
              // Still in delay period - completely transparent
              fadeInAlpha = 0;
            }
            
            // Fade out at outer edges - very aggressive blurry boundary effect to break perfect circle
            // Account for max radius variation: particles can be up to baseRadius + 17.5px
            const maxPossibleRadius = this.baseRadius + 17.5; // Maximum radius particles can have
            const fadeStartRadius = this.baseRadius * 0.5; // Start fading much earlier at 50% of baseRadius
            const fadeEndRadius = this.baseRadius * 0.7; // Fully transparent by 70% (much earlier)
            let edgeFade = 1.0;
            
            if (this.radius > fadeStartRadius) {
              // Calculate fade: 1.0 at fadeStartRadius, 0.0 at fadeEndRadius
              const fadeProgress = (this.radius - fadeStartRadius) / (fadeEndRadius - fadeStartRadius);
              edgeFade = Math.max(0, 1 - fadeProgress * 1.5); // Faster fade - steeper curve
            }
            
            // Very aggressive fade for any particles beyond fadeEndRadius
            // This ensures no particles are visible near the edge, completely breaking the circle
            if (this.radius > fadeEndRadius) {
              const extraFade = (this.radius - fadeEndRadius) / (maxPossibleRadius - fadeEndRadius);
              edgeFade *= Math.max(0, 1 - extraFade * 8); // Extremely aggressive fade - particles disappear instantly
            }
            
            // Size adjustment: particles get smaller as they approach center to prevent bunching
            // Gradual size reduction starting from 20% of journey
            const sizeReductionStart = this.baseRadius * 0.2; // Start reducing size when radius < 20% of base
            let depthSizeMultiplier = 1.0; // Default: full size
            
            if (this.radius < sizeReductionStart) {
              // Gradual size reduction as particles approach center
              const reductionProgress = this.radius / sizeReductionStart; // 0 at center, 1 at reduction start
              depthSizeMultiplier = 0.3 + reductionProgress * 0.7; // Size range: 0.3x at center to 1.0x at reduction start
            }
            
            const depthAdjustedSize = this.size * depthSizeMultiplier;
            
            // Opacity fade: particles FADE as they approach center (not brighter)
            // Reverse the opacity so particles become more transparent near center
            const centerFadeStart = this.baseRadius * 0.15; // Start fading when radius < 15% of base
            let centerFade = 1.0;
            
            if (this.radius < centerFadeStart) {
              // Fade out as particles approach center
              const fadeProgress = this.radius / centerFadeStart; // 0 at center, 1 at fade start
              centerFade = 0.2 + fadeProgress * 0.8; // Fade from 20% opacity at center to 100% at fade start
            }
            
            const baseAlpha = this.opacity * centerFade * (0.5 + distanceFromCenter * 0.5);
            
            // Soft light illumination: particles near center are brighter (illuminated by center light)
            const illuminationRadius = 40; // Radius of illumination effect from center light
            let illuminationMultiplier = 1.0;
            let brightnessBoost = 0; // Additional lightness for illumination
            
            if (this.radius < illuminationRadius) {
              // Particles within illumination radius get brighter
              const illuminationDistance = this.radius / illuminationRadius; // 0 at center, 1 at edge of illumination
              // Brightest at center, gradually dims outward
              illuminationMultiplier = 1.0 + (1 - illuminationDistance) * 0.6; // 1.0x to 1.6x brightness
              brightnessBoost = (1 - illuminationDistance) * 15; // Up to 15% brighter at center
            }
            
            // Combine with edge fade and fade-in (preserve fade-in to prevent perfect circle)
            // Apply illumination to make particles near center brighter
            const alpha = baseAlpha * edgeFade * fadeInAlpha * illuminationMultiplier;
            
            // Don't draw if completely faded
            if (alpha < 0.01) return;
            
            // Soft glow for nebula spark effect - smooth fade outward (optimized, no shadowBlur)
            // Use depth-adjusted size for glow
            const glowSize = depthAdjustedSize * 3; // Larger glow area for nebula spark
            
            // Enhanced brightness for particles near center (illuminated by center light)
            // brightnessBoost is already calculated above
            const gradient = ctx.createRadialGradient(
              pos.x, pos.y, 0,
              pos.x, pos.y, glowSize
            );
            // Bright center fading to transparent edges - creates soft glow without performance hit
            // Enhanced brightness for illuminated particles near center
            gradient.addColorStop(0, `hsla(${this.hue}, 100%, ${Math.min(95, 80 + brightnessBoost)}%, ${alpha})`);
            gradient.addColorStop(0.3, `hsla(${this.hue}, 100%, ${Math.min(90, 75 + brightnessBoost * 0.8)}%, ${alpha * 0.8})`);
            gradient.addColorStop(0.6, `hsla(${this.hue}, 100%, ${Math.min(85, 70 + brightnessBoost * 0.6)}%, ${alpha * 0.4})`);
            gradient.addColorStop(0.85, `hsla(${this.hue}, 100%, ${Math.min(80, 65 + brightnessBoost * 0.4)}%, ${alpha * 0.15})`);
            gradient.addColorStop(1, `hsla(${this.hue}, 100%, 60%, 0)`);
            
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, depthAdjustedSize, 0, Math.PI * 2); // Use depth-adjusted size
            ctx.fill();
            ctx.restore();
          }
        }
        
        // EdgeParticle class - particles in blurry edge section that align with main spiral
        class EdgeParticle {
          constructor(creationTime) {
            this.creationTime = creationTime || performance.now();
            this.baseRadius = getCurrentBaseRadius();
            // Spawn in blurry edge area (85-95% of baseRadius)
            const edgeStart = this.baseRadius * 0.85;
            const edgeEnd = this.baseRadius * 0.95;
            this.radius = edgeStart + Math.random() * (edgeEnd - edgeStart);
            
            // Align with main spiral arms - use same arm system
            const armIndex = Math.floor(Math.random() * numArms);
            const armAngle = (armIndex / numArms) * Math.PI * 2;
            // Add spiral offset to align with main particles
            const spiralOffset = Math.random() * Math.PI * 0.5; // Random position along spiral
            this.angle = armAngle + spiralOffset;
            this.armIndex = armIndex; // Store for continuity
            
            // Same pull speed as main particles for unified feel
            this.pullSpeed = 0.97 + Math.random() * 0.01;
            // Base speed same as main particles
            this.baseSpeed = 0.007 + Math.random() * 0.003;
            
            // Same size range as main particles
            this.size = 0.6 + Math.random() * 3.0;
            
            // Use same color calculation as main particles for unified appearance
            const normalizedAngle = ((this.angle % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);
            const angleColorProgress = normalizedAngle / (Math.PI * 2);
            const signatureHue = 44; // #fbb600 signature color
            const hueRange = 30;
            const baseHue = signatureHue + (angleColorProgress - 0.5) * hueRange;
            this.hue = (baseHue + (Math.random() - 0.5) * 6) % 360;
            
            // Same opacity range as main particles
            this.opacity = 0.65 + Math.random() * 0.35;
            
            // Fade-in like main particles
            this.fadeInDuration = 0.3 + Math.random() * 0.9;
            this.fadeInDelay = Math.random() * 0.3;
          }
          
          update(time) {
            // Use same speed calculation as main particles for unified motion
            const normalizedRadius = Math.max(this.radius / this.baseRadius, 0.1);
            const speedMultiplier = 0.5 + (1 / normalizedRadius) * 0.8;
            const adjustedSpeed = this.baseSpeed * speedMultiplier;
            
            // Same spiral motion as main particles
            this.angle += adjustedSpeed;
            this.radius *= this.pullSpeed;
            
            // When particle moves into main vortex area (below 80%), it becomes part of main flow
            // Reset when too close to center or too far out
            if (this.radius < 5 || this.radius > this.baseRadius * 1.1) {
              this.baseRadius = getCurrentBaseRadius();
              const edgeStart = this.baseRadius * 0.85;
              const edgeEnd = this.baseRadius * 0.95;
              this.radius = edgeStart + Math.random() * (edgeEnd - edgeStart);
              // Maintain spiral alignment
              const armAngle = (this.armIndex / numArms) * Math.PI * 2;
              const spiralOffset = Math.random() * Math.PI * 0.5;
              this.angle = armAngle + spiralOffset + (rotation % (Math.PI * 2));
              this.creationTime = time;
              this.fadeInDuration = 0.3 + Math.random() * 0.9;
              this.fadeInDelay = Math.random() * 0.3;
            }
          }
          
          getPosition() {
            const x = centerX() + Math.cos(this.angle + rotation) * this.radius;
            const y = centerY() + Math.sin(this.angle + rotation) * this.radius;
            return { x, y };
          }
          
          draw(currentTime) {
            const pos = this.getPosition();
            const distanceFromCenter = Math.min(this.radius / this.baseRadius, 1);
            
            // Same fade-in effect as main particles
            const timeSinceCreation = (currentTime - this.creationTime) / 1000;
            const timeAfterDelay = Math.max(0, timeSinceCreation - (this.fadeInDelay || 0));
            let fadeInAlpha = 1.0;
            
            if (timeAfterDelay < this.fadeInDuration) {
              const progress = Math.min(1, timeAfterDelay / this.fadeInDuration);
              fadeInAlpha = progress * progress * (3 - 2 * progress); // Smoothstep
            } else if (timeSinceCreation < (this.fadeInDelay || 0)) {
              fadeInAlpha = 0;
            }
            
            // Fade based on distance from center - smooth transition (more visible)
            let edgeFade = 1.0;
            if (distanceFromCenter > 0.92) {
              // Fade out at outer edge (less aggressive)
              edgeFade = Math.max(0.4, 1 - (distanceFromCenter - 0.92) * 7.5);
            }
            if (distanceFromCenter < 0.3) {
              // Smoothly transition into main vortex area (stay visible longer)
              edgeFade = Math.max(0.5, distanceFromCenter / 0.3);
            }
            
            const alpha = this.opacity * fadeInAlpha * edgeFade;
            
            if (alpha < 0.01) return;
            
            // Same drawing style as main particles for unified look
            const depthAdjustedSize = this.size;
            const gradient = ctx.createRadialGradient(
              pos.x, pos.y, 0,
              pos.x, pos.y, depthAdjustedSize * 3
            );
            gradient.addColorStop(0, `hsla(${this.hue}, 100%, ${Math.min(95, 80)}%, ${alpha})`);
            gradient.addColorStop(0.3, `hsla(${this.hue}, 100%, ${Math.min(90, 75)}%, ${alpha * 0.8})`);
            gradient.addColorStop(0.6, `hsla(${this.hue}, 100%, ${Math.min(85, 70)}%, ${alpha * 0.4})`);
            gradient.addColorStop(0.85, `hsla(${this.hue}, 100%, ${Math.min(80, 65)}%, ${alpha * 0.15})`);
            gradient.addColorStop(1, `hsla(${this.hue}, 100%, 60%, 0)`);
            
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, depthAdjustedSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        }
        
        // Start with 0 particles - will build up gradually
        
        // Track center light intensity - appears when particles are near center
        let targetCoreIntensity = 0;
        let currentCoreIntensity = 0;
        const coreIntensitySmoothing = 0.04; // Much slower, very gradual fade-in
        const centerRadius = 1.5; // Radius where particles disappear
        const lightActivationRadius = 8; // Light starts appearing when particles are very close to center
        const lightFullRadius = 3; // Light reaches 100% when particles are at the center
        
        // Draw bright central core - only appears when particles reach the center
        function drawCore(elapsed) {
          if (particles.length === 0) {
            targetCoreIntensity = 0;
            currentCoreIntensity = 0;
            return;
          }
          
          // Find the closest particle to center
          const currentBaseRadius = getCurrentBaseRadius();
          let closestRadius = currentBaseRadius;
          for (let particle of particles) {
            if (particle.radius < closestRadius) {
              closestRadius = particle.radius;
            }
          }
          
          // Light only appears when particles actually reach the center (very close)
          if (closestRadius > lightActivationRadius) {
            targetCoreIntensity = 0;
            // Smoothly fade out if particles move away
            currentCoreIntensity += (targetCoreIntensity - currentCoreIntensity) * coreIntensitySmoothing;
            if (currentCoreIntensity < 0.01) return;
          } else {
            // Calculate intensity: 0% when particles reach activation radius (8px), 100% when at center (3px)
            // Linear interpolation from lightActivationRadius to lightFullRadius
            const progress = 1 - (closestRadius - lightFullRadius) / (lightActivationRadius - lightFullRadius);
            targetCoreIntensity = Math.max(0, Math.min(1, progress)); // Clamp between 0 and 1
          }
          
          // Very slow, smooth interpolation for gradual fade
          currentCoreIntensity += (targetCoreIntensity - currentCoreIntensity) * coreIntensitySmoothing;
          
          // Only draw if intensity is significant
          if (currentCoreIntensity < 0.01) return;
          
          const coreSize = 10; // Smaller center light
          const deadCenterRadius = 4; // Slightly larger solid dead center for more visibility
          const cx = centerX(); // Fixed center X
          const cy = centerY(); // Fixed center Y
          
          ctx.save();
          ctx.globalCompositeOperation = 'screen';
          
          // Draw solid dead center - completely static, no rotation
          // Use solid fill for inner core to make it clearly non-rotating
          ctx.fillStyle = `rgba(255, 255, 255, ${0.95 * currentCoreIntensity})`; // Bright white solid center
          ctx.beginPath();
          ctx.arc(cx, cy, deadCenterRadius, 0, Math.PI * 2);
          ctx.fill();
          
          // Draw outer glow - perfectly circular, static gradient
          const coreGradient = ctx.createRadialGradient(
            cx, cy, deadCenterRadius,
            cx, cy, coreSize
          );
          coreGradient.addColorStop(0, `rgba(255, 255, 200, ${0.8 * currentCoreIntensity})`); // Yellow-white
          coreGradient.addColorStop(0.4, `rgba(255, 221, 85, ${0.6 * currentCoreIntensity})`); // Yellow
          coreGradient.addColorStop(0.7, `rgba(251, 182, 0, ${0.3 * currentCoreIntensity})`); // Orange
          coreGradient.addColorStop(1, 'rgba(251, 182, 0, 0)');
          
          ctx.fillStyle = coreGradient;
          ctx.beginPath();
          ctx.arc(cx, cy, coreSize, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.restore();
        }
        
        // Frame throttling for better performance
        let lastFrameTime = 0;
        const targetFPS = isMobile ? 30 : 60;
        const frameInterval = 1000 / targetFPS;
        
        function animate(time) {
          if (startTime === null) startTime = time;
          const elapsed = (time - startTime) / 1000;
          
          // Throttle frame rate for better performance
          const deltaTime = time - lastFrameTime;
          if (deltaTime < frameInterval) {
            animationId = requestAnimationFrame(animate);
            return;
          }
          lastFrameTime = time - (deltaTime % frameInterval);
          
          // Clear canvas - optimized (no expensive fillRect)
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          // Clockwise rotation - Very slow speed for visible spiral
          rotation += 0.012; // Increased vortex speed
          
          // Gradually add particles to form spiral (start from 0)
          // Stop adding when first particle disappears, then regeneration handles continuity
          if (!firstParticleDisappeared && activeParticleCount < calculatedMaxParticles && elapsed > 0.2) {
            const toAdd = Math.min(particlesPerFrame, calculatedMaxParticles - activeParticleCount);
            for (let i = 0; i < toAdd; i++) {
              const armIndex = globalCreationCounter % numArms;
              const particleIndex = Math.floor(globalCreationCounter / numArms);
              particles.push(new Particle(armIndex, particleIndex, calculatedMaxParticles, globalCreationCounter, time));
              activeParticleCount++;
              globalCreationCounter++;
            }
          }
          
          // Add edge particles in blurry section (spawn every 50ms, max 50 edge particles for better visibility)
          const maxEdgeParticles = 50;
          if (edgeParticleCount < maxEdgeParticles && time - lastEdgeParticleTime > 50) {
            edgeParticles.push(new EdgeParticle(time));
            edgeParticleCount++;
            lastEdgeParticleTime = time;
          }
          
          // Draw bright central core
          drawCore(elapsed);
          
          // Update and draw main particles
          particles.forEach(particle => {
            particle.update(time);
            particle.draw(time);
          });
          
          // Update and draw edge particles (in blurry section)
          edgeParticles.forEach((particle, index) => {
            particle.update(time);
            particle.draw(time);
            // Remove if too close to center or regenerated
            if (particle.radius < 5) {
              edgeParticles.splice(index, 1);
              edgeParticleCount--;
            }
          });
          
          animationId = requestAnimationFrame(animate);
        }
        
        // Start animation
        animate(performance.now());
        
        // Interactive tilt effect on mouse movement
        let tiltX = 0;
        let tiltY = 0;
        const maxTilt = 18; // Maximum tilt angle in degrees
        let isHovering = false;
        
        portalContainer.addEventListener('mouseenter', () => {
          isHovering = true;
        });
        
        portalContainer.addEventListener('mousemove', (e) => {
          if (!isHovering) return;
          
          const rect = portalContainer.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          
          // Calculate mouse position relative to center (-1 to 1)
          const mouseX = (e.clientX - centerX) / (rect.width / 2);
          const mouseY = (e.clientY - centerY) / (rect.height / 2);
          
          // Calculate tilt angles (invert Y for natural feel)
          tiltY = mouseX * maxTilt; // Tilt left/right based on X
          tiltX = -mouseY * maxTilt; // Tilt up/down based on Y (inverted)
          
          // Apply tilt to container with base scale
          portalContainer.style.transform = `translate3d(0, 0, 0) rotateX(${tiltX}deg) rotateY(${tiltY}deg) scale(1)`;
        });
        
        portalContainer.addEventListener('mouseleave', () => {
          isHovering = false;
          // Reset tilt when mouse leaves
          tiltX = 0;
          tiltY = 0;
          portalContainer.style.transform = '';
        });
        
        // Handle clicks - black overlay closes from edges to vortex center
        portalContainer.addEventListener('click', () => {
          // Prevent multiple clicks
          if (document.body.classList.contains('fading-out')) return;
          
          // Get vortex center position on screen
          const rect = portalContainer.getBoundingClientRect();
          const vortexCenterX = rect.left + rect.width / 2;
          const vortexCenterY = rect.top + rect.height / 2;
          
          // Get black overlay element
          const overlay = document.getElementById('black-overlay');
          
          // Animate black ring shrinking from edges to vortex center
          if (overlay) {
            const screenDiagonal = Math.sqrt(window.innerWidth ** 2 + window.innerHeight ** 2);
            const ringThickness = 30;
            let startTime = performance.now();
            const duration = 800;
            
            // Animate the ring shrinking from edges to center
            const animateRing = (currentTime) => {
              const elapsed = currentTime - startTime;
              const progress = Math.min(elapsed / duration, 1);
              const eased = progress * progress * (3 - 2 * progress); // smoothstep
              
              // Calculate current ring radius (starts at screen diagonal, shrinks to 0)
              const currentRadius = screenDiagonal * (1 - eased);
              const innerRadius = Math.max(0, currentRadius - ringThickness);
              
              // Create radial gradient for ring effect (black outside and ring, transparent center)
              overlay.style.background = `radial-gradient(circle at ${vortexCenterX}px ${vortexCenterY}px, 
                transparent ${innerRadius}px, 
                #000000 ${innerRadius}px, 
                #000000 ${currentRadius}px, 
                #000000 ${currentRadius}px)`;
              
              if (progress < 1) {
                requestAnimationFrame(animateRing);
              }
            };
            
            overlay.classList.add('active');
            requestAnimationFrame(animateRing);
          }
          
          // Mark body as fading out
          document.body.classList.add('fading-out');
          
          // Navigate after overlay closes (0.8s)
          setTimeout(() => {
            window.location.href = '/world';
          }, 800);
        });
        
        // Step in button click handler
        const stepInButton = document.querySelector('.step-in-button');
        if (stepInButton) {
          stepInButton.addEventListener('click', () => {
            // Trigger the same navigation as portal click
            portalContainer.click();
          });
        }
      })();

      // Second Portal at Bottom - Same functionality
      (() => {
        const canvas = document.getElementById('vortex-portal-bottom');
        const portalContainer = document.getElementById('portal-container-bottom');
        
        if (!canvas || !portalContainer) return;
        
        const ctx = canvas.getContext('2d');
        let animationId = null;
        let startTime = null;
        let rotation = 0;
        
        // Resize canvas
        function resizeCanvas() {
          const rect = portalContainer.getBoundingClientRect();
          canvas.width = rect.width;
          canvas.height = rect.height;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Particle system - realistic vortex with 2 main arms
        const particles = [];
        const edgeParticles = []; // Particles in blurry edge section
        const numArms = 2; // Two main arms like reference
        let activeParticleCount = 0;
        let edgeParticleCount = 0;
        let globalCreationCounter = 0; // Track actual creation order
        let firstParticleDisappeared = false; // Track when first particle disappears
        let lastEdgeParticleTime = 0; // Track edge particle creation timing
        // Optimize particle count based on device performance
        const isMobile = window.innerWidth < 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const particlesPerFrame = isMobile ? 3 : 4; // Reduced generation rate for better performance
        const centerX = () => canvas.width / 2;
        const centerY = () => canvas.height / 2;
        
        // Ensure animation continues during expansion
        let isAnimating = true;
        
        // Base radius for particle field - scaled to half size for smaller portal
        const initialBaseRadius = 120;
        
        // Calculate max particles needed for continuous loop - optimized for performance
        const calculatedMaxParticles = isMobile ? 600 : 900; // Further reduced to prevent lag
        
        // Get current baseRadius
        function getCurrentBaseRadius() {
          return initialBaseRadius;
        }
        
        // Particle class - realistic small glowing dots (same as top portal)
        class Particle {
          constructor(armIndex, particleIndex, totalParticles, creationOrder, creationTime) {
            this.armIndex = armIndex;
            this.particleIndex = particleIndex;
            this.totalParticles = totalParticles;
            this.creationOrder = creationOrder; // Actual order of creation
            this.creationTime = creationTime || performance.now(); // Time when particle was created
            // Random fade-in: particles fade in at different rates when entering field
            this.fadeInDuration = 0.3 + Math.random() * 0.9; // More random: 0.3-1.2 seconds for varied appearance
            this.fadeInDelay = Math.random() * 0.3; // Random delay before fade-in starts (0-0.3s)
            this.reset(true);
          }
          
          reset(isInitial = false) {
            const armAngle = (this.armIndex / numArms) * Math.PI * 2;
            const baseRadius = getCurrentBaseRadius(); // Dynamic radius that expands
            
            // Spiral offset - creates clearly visible spiral arms
            // Use creation order to position particles along spiral with tighter spacing
            const baseSpiralOffset = this.creationOrder * 0.25; // Increased spacing for more distinct spiral arms
            const randomAngleVariation = (Math.random() - 0.5) * 0.05; // Minimal variation to maintain clear spiral
            const spiralOffset = baseSpiralOffset + randomAngleVariation;
            
            if (isInitial) {
              // For initial particles: start at outer edge with organic shape but maintain spiral
              const radiusVariation = (Math.random() - 0.5) * 35; // Organic edge variation
              const angleVariation = (Math.random() - 0.5) * 0.2; // Reduced angle variation to maintain spiral
              this.radius = baseRadius + radiusVariation; // Irregular outer edge
              this.angle = armAngle + spiralOffset + angleVariation;
            } else {
              // Regenerated particles: always start at outer edge with minimal variation to maintain spiral
              const radiusVariation = (Math.random() - 0.5) * 35; // Organic edge variation
              const angleVariation = (Math.random() - 0.5) * 0.15; // Reduced angle variation to maintain spiral
              this.radius = baseRadius + radiusVariation;
              this.angle = armAngle + this.initialSpiralOffset + (rotation % (Math.PI * 2)) + angleVariation;
            }
            
            this.baseRadius = baseRadius;
            this.initialSpiralOffset = spiralOffset; // Store for maintaining spiral shape
            
            
            // Signature color palette: #fbb600 (44¬∞ orange-gold) and neighboring warm tones
            // Use angle to create color gradient that follows the spiral pattern
            const normalizedAngle = ((this.angle % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2); // Normalize to 0-2œÄ
            const angleColorProgress = normalizedAngle / (Math.PI * 2); // 0 to 1 based on angle
            
            // Signature color #fbb600 is ~44¬∞ (orange-gold)
            // Neighboring colors: red-orange (25¬∞), orange (35¬∞), signature (44¬∞), yellow-orange (50¬∞), yellow (55¬∞)
            // Create smooth gradient through these warm tones
            const signatureHue = 44; // #fbb600 signature color
            const hueRange = 30; // Range of neighboring colors (¬±15¬∞ from signature)
            const baseHue = signatureHue + (angleColorProgress - 0.5) * hueRange; // Vary ¬±15¬∞ around signature
            this.hue = (baseHue + (Math.random() - 0.5) * 6) % 360; // Add slight random variation, wrap around
            this.opacity = 0.65 + Math.random() * 0.35; // Increased opacity by ~15% for better visibility (0.65-1.0)
            
            // Small varied sizes for realistic feel - more variation
            this.size = 0.6 + Math.random() * 3.0; // More size variation
            // Base rotation speed: will be adjusted based on distance from center
            // Particles near center rotate faster, outer ones slower (realistic spiral motion)
            this.baseSpeed = 0.007 + Math.random() * 0.003; // Base speed for clear visibility
            this.speed = this.baseSpeed; // Initial speed, will be adjusted in update()
            this.pullSpeed = 0.97 + Math.random() * 0.01; // Faster pull to match rotation speed
          }
          
          update(time) {
            // Realistic spiral motion: particles near center rotate faster, outer ones slower
            // Speed is inversely proportional to radius (like real spiral galaxies)
            // Moderate speed difference - visible but not too fast
            const normalizedRadius = Math.max(this.radius / this.baseRadius, 0.1); // Normalize, prevent division by zero
            const speedMultiplier = 0.5 + (1 / normalizedRadius) * 0.8; // Moderate: 1x at edge, ~8-9x at center
            const adjustedSpeed = this.baseSpeed * speedMultiplier;
            
            // Clockwise rotation (positive) - speed varies based on distance from center
            this.angle += adjustedSpeed;
            
            // Pull inward - each particle has its own pull speed (set in reset)
            this.radius *= this.pullSpeed;
            
            // Reset when very close to center (almost invisible)
            const resetThreshold = 1.5; // Very close to center - particles disappear when invisible
            
            // Force regeneration if particle is too close to center (invisible)
            if (this.radius < resetThreshold) {
              // Mark that first particle has disappeared (for initial build-up)
              if (this.creationOrder === 0 && !firstParticleDisappeared) {
                firstParticleDisappeared = true;
              }
              // Reset creation time for fade-in effect when regenerated
              this.creationTime = time;
              this.fadeInDuration = 0.3 + Math.random() * 0.9; // More random: 0.3-1.2 seconds for varied appearance
              this.fadeInDelay = Math.random() * 0.3; // Random delay before fade-in starts (0-0.3s)
              this.reset(false); // Regenerate at outer edge
            }
          }
          
          getPosition() {
            const x = centerX() + Math.cos(this.angle + rotation) * this.radius;
            const y = centerY() + Math.sin(this.angle + rotation) * this.radius;
            return { x, y };
          }
          
          draw(currentTime) {
            const pos = this.getPosition();
            const distanceFromCenter = Math.min(this.radius / this.baseRadius, 1);
            
            // Fade in effect - particles gradually appear when entering field (random timing)
            const timeSinceCreation = (currentTime - this.creationTime) / 1000; // Convert to seconds
            let fadeInAlpha = 1.0;
            
            // Account for random delay before fade-in starts
            const timeAfterDelay = Math.max(0, timeSinceCreation - (this.fadeInDelay || 0));
            
            if (timeAfterDelay < this.fadeInDuration) {
              // Gradually fade in from 0 to 1 over fadeInDuration with smooth easing
              const progress = Math.min(1, timeAfterDelay / this.fadeInDuration);
              // Smooth ease-in curve for more realistic, natural appearance
              fadeInAlpha = progress * progress * (3 - 2 * progress); // Smoothstep function for natural fade
            } else if (timeSinceCreation < (this.fadeInDelay || 0)) {
              // Still in delay period - completely transparent
              fadeInAlpha = 0;
            }
            
            // Fade out at outer edges - very aggressive blurry boundary effect to break perfect circle
            // Account for max radius variation: particles can be up to baseRadius + 17.5px
            const maxPossibleRadius = this.baseRadius + 17.5; // Maximum radius particles can have
            const fadeStartRadius = this.baseRadius * 0.5; // Start fading much earlier at 50% of baseRadius
            const fadeEndRadius = this.baseRadius * 0.7; // Fully transparent by 70% (much earlier)
            let edgeFade = 1.0;
            
            if (this.radius > fadeStartRadius) {
              // Calculate fade: 1.0 at fadeStartRadius, 0.0 at fadeEndRadius
              const fadeProgress = (this.radius - fadeStartRadius) / (fadeEndRadius - fadeStartRadius);
              edgeFade = Math.max(0, 1 - fadeProgress * 1.5); // Faster fade - steeper curve
            }
            
            // Very aggressive fade for any particles beyond fadeEndRadius
            // This ensures no particles are visible near the edge, completely breaking the circle
            if (this.radius > fadeEndRadius) {
              const extraFade = (this.radius - fadeEndRadius) / (maxPossibleRadius - fadeEndRadius);
              edgeFade *= Math.max(0, 1 - extraFade * 8); // Extremely aggressive fade - particles disappear instantly
            }
            
            // Size adjustment: particles get smaller as they approach center to prevent bunching
            // Gradual size reduction starting from 20% of journey
            const sizeReductionStart = this.baseRadius * 0.2; // Start reducing size when radius < 20% of base
            let depthSizeMultiplier = 1.0; // Default: full size
            
            if (this.radius < sizeReductionStart) {
              // Gradual size reduction as particles approach center
              const reductionProgress = this.radius / sizeReductionStart; // 0 at center, 1 at reduction start
              depthSizeMultiplier = 0.3 + reductionProgress * 0.7; // Size range: 0.3x at center to 1.0x at reduction start
            }
            
            const depthAdjustedSize = this.size * depthSizeMultiplier;
            
            // Opacity fade: particles FADE as they approach center (not brighter)
            // Reverse the opacity so particles become more transparent near center
            const centerFadeStart = this.baseRadius * 0.15; // Start fading when radius < 15% of base
            let centerFade = 1.0;
            
            if (this.radius < centerFadeStart) {
              // Fade out as particles approach center
              const fadeProgress = this.radius / centerFadeStart; // 0 at center, 1 at fade start
              centerFade = 0.2 + fadeProgress * 0.8; // Fade from 20% opacity at center to 100% at fade start
            }
            
            const baseAlpha = this.opacity * centerFade * (0.5 + distanceFromCenter * 0.5);
            
            // Soft light illumination: particles near center are brighter (illuminated by center light)
            const illuminationRadius = 40; // Radius of illumination effect from center light
            let illuminationMultiplier = 1.0;
            let brightnessBoost = 0; // Additional lightness for illumination
            
            if (this.radius < illuminationRadius) {
              // Particles within illumination radius get brighter
              const illuminationDistance = this.radius / illuminationRadius; // 0 at center, 1 at edge of illumination
              // Brightest at center, gradually dims outward
              illuminationMultiplier = 1.0 + (1 - illuminationDistance) * 0.6; // 1.0x to 1.6x brightness
              brightnessBoost = (1 - illuminationDistance) * 15; // Up to 15% brighter at center
            }
            
            // Combine with edge fade and fade-in (preserve fade-in to prevent perfect circle)
            // Apply illumination to make particles near center brighter
            const alpha = baseAlpha * edgeFade * fadeInAlpha * illuminationMultiplier;
            
            // Don't draw if completely faded
            if (alpha < 0.01) return;
            
            // Soft glow for nebula spark effect - smooth fade outward (optimized, no shadowBlur)
            // Use depth-adjusted size for glow
            const glowSize = depthAdjustedSize * 3; // Larger glow area for nebula spark
            
            // Enhanced brightness for particles near center (illuminated by center light)
            // brightnessBoost is already calculated above
            const gradient = ctx.createRadialGradient(
              pos.x, pos.y, 0,
              pos.x, pos.y, glowSize
            );
            // Bright center fading to transparent edges - creates soft glow without performance hit
            // Enhanced brightness for illuminated particles near center
            gradient.addColorStop(0, `hsla(${this.hue}, 100%, ${Math.min(95, 80 + brightnessBoost)}%, ${alpha})`);
            gradient.addColorStop(0.3, `hsla(${this.hue}, 100%, ${Math.min(90, 75 + brightnessBoost * 0.8)}%, ${alpha * 0.8})`);
            gradient.addColorStop(0.6, `hsla(${this.hue}, 100%, ${Math.min(85, 70 + brightnessBoost * 0.6)}%, ${alpha * 0.4})`);
            gradient.addColorStop(0.85, `hsla(${this.hue}, 100%, ${Math.min(80, 65 + brightnessBoost * 0.4)}%, ${alpha * 0.15})`);
            gradient.addColorStop(1, `hsla(${this.hue}, 100%, 60%, 0)`);
            
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, depthAdjustedSize, 0, Math.PI * 2); // Use depth-adjusted size
            ctx.fill();
            ctx.restore();
          }
        }
        
        // EdgeParticle class - particles in blurry edge section that align with main spiral
        class EdgeParticle {
          constructor(creationTime) {
            this.creationTime = creationTime || performance.now();
            this.baseRadius = getCurrentBaseRadius();
            // Spawn in blurry edge area (85-95% of baseRadius)
            const edgeStart = this.baseRadius * 0.85;
            const edgeEnd = this.baseRadius * 0.95;
            this.radius = edgeStart + Math.random() * (edgeEnd - edgeStart);
            
            // Align with main spiral arms - use same arm system
            const armIndex = Math.floor(Math.random() * numArms);
            const armAngle = (armIndex / numArms) * Math.PI * 2;
            // Add spiral offset to align with main particles
            const spiralOffset = Math.random() * Math.PI * 0.5; // Random position along spiral
            this.angle = armAngle + spiralOffset;
            this.armIndex = armIndex; // Store for continuity
            
            // Same pull speed as main particles for unified feel
            this.pullSpeed = 0.97 + Math.random() * 0.01;
            // Base speed same as main particles
            this.baseSpeed = 0.007 + Math.random() * 0.003;
            
            // Same size range as main particles
            this.size = 0.6 + Math.random() * 3.0;
            
            // Use same color calculation as main particles for unified appearance
            const normalizedAngle = ((this.angle % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);
            const angleColorProgress = normalizedAngle / (Math.PI * 2);
            const signatureHue = 44; // #fbb600 signature color
            const hueRange = 30;
            const baseHue = signatureHue + (angleColorProgress - 0.5) * hueRange;
            this.hue = (baseHue + (Math.random() - 0.5) * 6) % 360;
            
            // Same opacity range as main particles
            this.opacity = 0.65 + Math.random() * 0.35;
            
            // Fade-in like main particles
            this.fadeInDuration = 0.3 + Math.random() * 0.9;
            this.fadeInDelay = Math.random() * 0.3;
          }
          
          update(time) {
            // Use same speed calculation as main particles for unified motion
            const normalizedRadius = Math.max(this.radius / this.baseRadius, 0.1);
            const speedMultiplier = 0.5 + (1 / normalizedRadius) * 0.8;
            const adjustedSpeed = this.baseSpeed * speedMultiplier;
            
            // Same spiral motion as main particles
            this.angle += adjustedSpeed;
            this.radius *= this.pullSpeed;
            
            // When particle moves into main vortex area (below 80%), it becomes part of main flow
            // Reset when too close to center or too far out
            if (this.radius < 5 || this.radius > this.baseRadius * 1.1) {
              this.baseRadius = getCurrentBaseRadius();
              const edgeStart = this.baseRadius * 0.85;
              const edgeEnd = this.baseRadius * 0.95;
              this.radius = edgeStart + Math.random() * (edgeEnd - edgeStart);
              // Maintain spiral alignment
              const armAngle = (this.armIndex / numArms) * Math.PI * 2;
              const spiralOffset = Math.random() * Math.PI * 0.5;
              this.angle = armAngle + spiralOffset + (rotation % (Math.PI * 2));
              this.creationTime = time;
              this.fadeInDuration = 0.3 + Math.random() * 0.9;
              this.fadeInDelay = Math.random() * 0.3;
            }
          }
          
          getPosition() {
            const x = centerX() + Math.cos(this.angle + rotation) * this.radius;
            const y = centerY() + Math.sin(this.angle + rotation) * this.radius;
            return { x, y };
          }
          
          draw(currentTime) {
            const pos = this.getPosition();
            const distanceFromCenter = Math.min(this.radius / this.baseRadius, 1);
            
            // Same fade-in effect as main particles
            const timeSinceCreation = (currentTime - this.creationTime) / 1000;
            const timeAfterDelay = Math.max(0, timeSinceCreation - (this.fadeInDelay || 0));
            let fadeInAlpha = 1.0;
            
            if (timeAfterDelay < this.fadeInDuration) {
              const progress = Math.min(1, timeAfterDelay / this.fadeInDuration);
              fadeInAlpha = progress * progress * (3 - 2 * progress); // Smoothstep
            } else if (timeSinceCreation < (this.fadeInDelay || 0)) {
              fadeInAlpha = 0;
            }
            
            // Fade based on distance from center - smooth transition (more visible)
            let edgeFade = 1.0;
            if (distanceFromCenter > 0.92) {
              // Fade out at outer edge (less aggressive)
              edgeFade = Math.max(0.4, 1 - (distanceFromCenter - 0.92) * 7.5);
            }
            if (distanceFromCenter < 0.3) {
              // Smoothly transition into main vortex area (stay visible longer)
              edgeFade = Math.max(0.5, distanceFromCenter / 0.3);
            }
            
            const alpha = this.opacity * fadeInAlpha * edgeFade;
            
            if (alpha < 0.01) return;
            
            // Same drawing style as main particles for unified look
            const depthAdjustedSize = this.size;
            const gradient = ctx.createRadialGradient(
              pos.x, pos.y, 0,
              pos.x, pos.y, depthAdjustedSize * 3
            );
            gradient.addColorStop(0, `hsla(${this.hue}, 100%, ${Math.min(95, 80)}%, ${alpha})`);
            gradient.addColorStop(0.3, `hsla(${this.hue}, 100%, ${Math.min(90, 75)}%, ${alpha * 0.8})`);
            gradient.addColorStop(0.6, `hsla(${this.hue}, 100%, ${Math.min(85, 70)}%, ${alpha * 0.4})`);
            gradient.addColorStop(0.85, `hsla(${this.hue}, 100%, ${Math.min(80, 65)}%, ${alpha * 0.15})`);
            gradient.addColorStop(1, `hsla(${this.hue}, 100%, 60%, 0)`);
            
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, depthAdjustedSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        }
        
        // Start with 0 particles - will build up gradually
        
        // Track center light intensity - appears when particles are near center
        let targetCoreIntensity = 0;
        let currentCoreIntensity = 0;
        const coreIntensitySmoothing = 0.04; // Much slower, very gradual fade-in
        const centerRadius = 1.5; // Radius where particles disappear
        const lightActivationRadius = 8; // Light starts appearing when particles are very close to center
        const lightFullRadius = 3; // Light reaches 100% when particles are at the center
        
        // Draw bright central core - only appears when particles reach the center
        function drawCore(elapsed) {
          if (particles.length === 0) {
            targetCoreIntensity = 0;
            currentCoreIntensity = 0;
            return;
          }
          
          // Find the closest particle to center
          const currentBaseRadius = getCurrentBaseRadius();
          let closestRadius = currentBaseRadius;
          for (let particle of particles) {
            if (particle.radius < closestRadius) {
              closestRadius = particle.radius;
            }
          }
          
          // Light only appears when particles actually reach the center (very close)
          if (closestRadius > lightActivationRadius) {
            targetCoreIntensity = 0;
            // Smoothly fade out if particles move away
            currentCoreIntensity += (targetCoreIntensity - currentCoreIntensity) * coreIntensitySmoothing;
            if (currentCoreIntensity < 0.01) return;
          } else {
            // Calculate intensity: 0% when particles reach activation radius (8px), 100% when at center (3px)
            // Linear interpolation from lightActivationRadius to lightFullRadius
            const progress = 1 - (closestRadius - lightFullRadius) / (lightActivationRadius - lightFullRadius);
            targetCoreIntensity = Math.max(0, Math.min(1, progress)); // Clamp between 0 and 1
          }
          
          // Very slow, smooth interpolation for gradual fade
          currentCoreIntensity += (targetCoreIntensity - currentCoreIntensity) * coreIntensitySmoothing;
          
          // Only draw if intensity is significant
          if (currentCoreIntensity < 0.01) return;
          
          const coreSize = 10; // Smaller center light
          const deadCenterRadius = 4; // Slightly larger solid dead center for more visibility
          const cx = centerX(); // Fixed center X
          const cy = centerY(); // Fixed center Y
          
          ctx.save();
          ctx.globalCompositeOperation = 'screen';
          
          // Draw solid dead center - completely static, no rotation
          // Use solid fill for inner core to make it clearly non-rotating
          ctx.fillStyle = `rgba(255, 255, 255, ${0.95 * currentCoreIntensity})`; // Bright white solid center
          ctx.beginPath();
          ctx.arc(cx, cy, deadCenterRadius, 0, Math.PI * 2);
          ctx.fill();
          
          // Draw outer glow - perfectly circular, static gradient
          const coreGradient = ctx.createRadialGradient(
            cx, cy, deadCenterRadius,
            cx, cy, coreSize
          );
          coreGradient.addColorStop(0, `rgba(255, 255, 200, ${0.8 * currentCoreIntensity})`); // Yellow-white
          coreGradient.addColorStop(0.4, `rgba(255, 221, 85, ${0.6 * currentCoreIntensity})`); // Yellow
          coreGradient.addColorStop(0.7, `rgba(251, 182, 0, ${0.3 * currentCoreIntensity})`); // Orange
          coreGradient.addColorStop(1, 'rgba(251, 182, 0, 0)');
          
          ctx.fillStyle = coreGradient;
          ctx.beginPath();
          ctx.arc(cx, cy, coreSize, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.restore();
        }
        
        // Frame throttling for better performance
        let lastFrameTime = 0;
        const targetFPS = isMobile ? 30 : 60;
        const frameInterval = 1000 / targetFPS;
        
        function animate(time) {
          if (startTime === null) startTime = time;
          const elapsed = (time - startTime) / 1000;
          
          // Throttle frame rate for better performance
          const deltaTime = time - lastFrameTime;
          if (deltaTime < frameInterval) {
            animationId = requestAnimationFrame(animate);
            return;
          }
          lastFrameTime = time - (deltaTime % frameInterval);
          
          // Clear canvas - optimized (no expensive fillRect)
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          // Clockwise rotation - Very slow speed for visible spiral
          rotation += 0.012; // Increased vortex speed
          
          // Gradually add particles to form spiral (start from 0)
          // Stop adding when first particle disappears, then regeneration handles continuity
          if (!firstParticleDisappeared && activeParticleCount < calculatedMaxParticles && elapsed > 0.2) {
            const toAdd = Math.min(particlesPerFrame, calculatedMaxParticles - activeParticleCount);
            for (let i = 0; i < toAdd; i++) {
              const armIndex = globalCreationCounter % numArms;
              const particleIndex = Math.floor(globalCreationCounter / numArms);
              particles.push(new Particle(armIndex, particleIndex, calculatedMaxParticles, globalCreationCounter, time));
              activeParticleCount++;
              globalCreationCounter++;
            }
          }
          
          // Add edge particles in blurry section (spawn every 50ms, max 50 edge particles for better visibility)
          const maxEdgeParticles = 50;
          if (edgeParticleCount < maxEdgeParticles && time - lastEdgeParticleTime > 50) {
            edgeParticles.push(new EdgeParticle(time));
            edgeParticleCount++;
            lastEdgeParticleTime = time;
          }
          
          // Draw bright central core
          drawCore(elapsed);
          
          // Update and draw main particles
          particles.forEach(particle => {
            particle.update(time);
            particle.draw(time);
          });
          
          // Update and draw edge particles (in blurry section)
          edgeParticles.forEach((particle, index) => {
            particle.update(time);
            particle.draw(time);
            // Remove if too close to center or regenerated
            if (particle.radius < 5) {
              edgeParticles.splice(index, 1);
              edgeParticleCount--;
            }
          });
          
          animationId = requestAnimationFrame(animate);
        }
        
        // Start animation
        animate(performance.now());
        
        // Interactive tilt effect on mouse movement
        let tiltX = 0;
        let tiltY = 0;
        const maxTilt = 18; // Maximum tilt angle in degrees
        let isHovering = false;
        
        portalContainer.addEventListener('mouseenter', () => {
          isHovering = true;
        });
        
        portalContainer.addEventListener('mousemove', (e) => {
          if (!isHovering) return;
          
          const rect = portalContainer.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          
          // Calculate mouse position relative to center (-1 to 1)
          const mouseX = (e.clientX - centerX) / (rect.width / 2);
          const mouseY = (e.clientY - centerY) / (rect.height / 2);
          
          // Calculate tilt angles (invert Y for natural feel)
          tiltY = mouseX * maxTilt; // Tilt left/right based on X
          tiltX = -mouseY * maxTilt; // Tilt up/down based on Y (inverted)
          
          // Apply tilt to container with base scale
          portalContainer.style.transform = `translate3d(0, 0, 0) rotateX(${tiltX}deg) rotateY(${tiltY}deg) scale(1)`;
        });
        
        portalContainer.addEventListener('mouseleave', () => {
          isHovering = false;
          // Reset tilt when mouse leaves
          tiltX = 0;
          tiltY = 0;
          portalContainer.style.transform = '';
        });
        
        // Handle clicks - black overlay closes from edges to vortex center
        portalContainer.addEventListener('click', () => {
          // Prevent multiple clicks
          if (document.body.classList.contains('fading-out')) return;
          
          // Get vortex center position on screen
          const rect = portalContainer.getBoundingClientRect();
          const vortexCenterX = rect.left + rect.width / 2;
          const vortexCenterY = rect.top + rect.height / 2;
          
          // Get black overlay element
          const overlay = document.getElementById('black-overlay');
          
          // Animate black ring shrinking from edges to vortex center
          if (overlay) {
            const screenDiagonal = Math.sqrt(window.innerWidth ** 2 + window.innerHeight ** 2);
            const ringThickness = 30;
            let startTime = performance.now();
            const duration = 800;
            
            // Animate the ring shrinking from edges to center
            const animateRing = (currentTime) => {
              const elapsed = currentTime - startTime;
              const progress = Math.min(elapsed / duration, 1);
              const eased = progress * progress * (3 - 2 * progress); // smoothstep
              
              // Calculate current ring radius (starts at screen diagonal, shrinks to 0)
              const currentRadius = screenDiagonal * (1 - eased);
              const innerRadius = Math.max(0, currentRadius - ringThickness);
              
              // Create radial gradient for ring effect (black outside and ring, transparent center)
              overlay.style.background = `radial-gradient(circle at ${vortexCenterX}px ${vortexCenterY}px, 
                transparent ${innerRadius}px, 
                #000000 ${innerRadius}px, 
                #000000 ${currentRadius}px, 
                #000000 ${currentRadius}px)`;
              
              if (progress < 1) {
                requestAnimationFrame(animateRing);
              }
            };
            
            overlay.classList.add('active');
            requestAnimationFrame(animateRing);
          }
          
          // Mark body as fading out
          document.body.classList.add('fading-out');
          
          // Navigate after overlay closes (0.8s)
          setTimeout(() => {
            window.location.href = '/world';
          }, 800);
        });
      })();
    });

    // Custom cursor system
    if (window.matchMedia('(hover: hover)').matches) {
      const cursor = document.querySelector('.custom-cursor');
      let cursorX = 0, cursorY = 0;
      let targetX = 0, targetY = 0;
      let isAnimating = false;

      function updateCursor() {
        // Use a more responsive interpolation (higher factor = more responsive)
        const lerpFactor = 0.15; // Increased from ~0.1-0.3 for better responsiveness
        const dx = targetX - cursorX;
        const dy = targetY - cursorY;
        
        // Only update if there's meaningful movement (performance optimization)
        if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {
          cursorX += dx * lerpFactor;
          cursorY += dy * lerpFactor;
          cursor.style.transform = `translate3d(${cursorX}px, ${cursorY}px, 0)`;
          isAnimating = true;
        } else {
          isAnimating = false;
        }
        
        if (isAnimating) {
          requestAnimationFrame(updateCursor);
        }
      }

      // Start animation loop
      updateCursor();

      document.addEventListener('mousemove', e => {
        targetX = e.clientX - 10;
        targetY = e.clientY - 10;
        
        // Restart animation if it stopped
        if (!isAnimating) {
          updateCursor();
        }
      }, { passive: true });
    }

    // Show the R button after scrolling past hero
    document.addEventListener('DOMContentLoaded', () => {
      const trigger = document.querySelector('.arc-menu-trigger');
      const arcMenu = document.querySelector('.arc-menu');
      const items = document.querySelectorAll('.arc-menu-item');
      // Show trigger after hero
      const hero = document.querySelector('header.hero');
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (!entry.isIntersecting) {
            trigger.classList.add('visible');
          } else {
            trigger.classList.remove('visible');
            arcMenu.classList.remove('open');
          }
        });
      }, { threshold: 0.1 });
      if (hero) observer.observe(hero);
      // Arc menu open/close
      trigger.addEventListener('click', (e) => {
        e.stopPropagation();
        arcMenu.classList.toggle('open');
        if (arcMenu.classList.contains('open')) {
          let radius, total, arcStart, arcEnd, centerX, centerY;
          const isMobile = window.innerWidth <= 1024;
          const rRect = trigger.getBoundingClientRect();
          const menuRect = arcMenu.getBoundingClientRect();
          if (isMobile) {
            // Top left corner, 360¬∞ (right) to 450¬∞ (up right) - quarter circle
            radius = 70;
            total = items.length;
            arcStart = 360;   // right
            arcEnd = 450;     // up right
            centerX = rRect.left + rRect.width / 2 - menuRect.left;
            centerY = rRect.top + rRect.height / 2 - menuRect.top;
          } else {
            // Desktop: left center, 140-degree arc
            radius = 70;
            total = items.length;
            arcStart = -70; // degrees (bottom)
            arcEnd = 70;   // degrees (top)
            centerX = rRect.left + rRect.width / 2 - menuRect.left + 6; // nudge right more
            centerY = rRect.top + rRect.height / 2 - menuRect.top - 10; // nudge up more
          }
          items.forEach((item, i) => {
            const angleDeg = arcStart + (arcEnd - arcStart) * (i / (total - 1));
            item.style.left = centerX + 'px';
            item.style.top = centerY + 'px';
            item.style.transform = `scale(1) rotate(${angleDeg}deg) translateX(${radius}px)`;
            // Counter-rotate the text so it's upright only on desktop
            const textSpan = item.querySelector('span');
            if (textSpan) {
              textSpan.style.display = 'inline-block';
              if (isMobile) {
                textSpan.style.transform = 'none';
              } else {
                textSpan.style.transform = `rotate(${-angleDeg}deg)`;
              }
            }
          });
        } else {
          // Reset transforms when closing
          items.forEach(item => {
            item.style.transform = 'scale(0)';
            // Reset counter-rotation
            const textSpan = item.querySelector('span');
            if (textSpan) {
              textSpan.style.transform = '';
            }
          });
        }
      });
      // Close menu on click outside
      document.addEventListener('click', (e) => {
        if (!arcMenu.contains(e.target) && !trigger.contains(e.target)) {
          arcMenu.classList.remove('open');
          items.forEach(item => {
            item.style.transform = 'scale(0)';
          });
        }
      });
      // Auto-close menu on wheel (scroll) for fixed menus
      window.addEventListener('wheel', () => {
        arcMenu.classList.remove('open');
        items.forEach(item => {
          item.style.transform = 'scale(0)';
        });
      }, { passive: true });
      // Auto-close menu on mouse leave from the whole arc-menu area
      arcMenu.addEventListener('mouseleave', (e) => {
        // Only close if the mouse is truly leaving the arc-menu, not just moving between items
        if (!arcMenu.contains(e.relatedTarget)) {
          arcMenu.classList.remove('open');
          items.forEach(item => {
            item.style.transform = 'scale(0)';
          });
        }
      });
      // Optional: handle menu item clicks
      items.forEach(item => {
        item.addEventListener('click', () => {
          arcMenu.classList.remove('open');
          items.forEach(item => {
            item.style.transform = 'scale(0)';
          });
          // Add navigation logic here if needed
        });
      });
    });
  </script>
</body>
</html>
